<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI PDF Watermark Remover - ToolMatrix</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<style>
body{
  margin:0;
  font-family:Arial;
  background:linear-gradient(135deg,#007bff,#4da3ff);
  color:white;
}
.container{
  max-width:1300px;
  margin:auto;
  padding:20px;
}
.card{
  background:white;
  color:black;
  border-radius:14px;
  padding:20px;
  margin-top:20px;
  box-shadow:0 15px 35px rgba(0,0,0,0.2);
}
h1{text-align:center;}
.controls{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}
button{
  background:#007bff;
  border:none;
  padding:10px 15px;
  border-radius:8px;
  color:white;
  cursor:pointer;
}
button:hover{background:#0056b3;}
.preview-grid{
  display:flex;
  gap:20px;
  flex-wrap:wrap;
}
canvas{
  width:100%;
  border-radius:8px;
  border:1px solid #ccc;
}
.canvas-wrapper{
  position:relative;
}
.selection-box{
  position:absolute;
  border:2px dashed red;
  pointer-events:none;
}
</style>
</head>
<body>

<div class="container">
<h1>AI PDF Watermark Remover</h1>

<div class="card">

<input type="file" id="pdfInput" accept="application/pdf">

<div class="controls">
<button onclick="enableManualSelect()">Manual Select Mode</button>
<button onclick="applyBlur()">AI Blur Removal</button>
<button onclick="applyDarkMode()">Dark Watermark Mode</button>
<button onclick="removeTextWatermark()">Text Watermark Remove</button>
<button onclick="downloadPDF()">Download Clean PDF</button>
</div>

<div class="preview-grid">
<div style="flex:1">
<h3>Original</h3>
<div id="original"></div>
</div>
<div style="flex:1">
<h3>Processed</h3>
<div id="processed"></div>
</div>
</div>

</div>
</div>

<script>

const pdfjsLib = window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc =
'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

let originalBytes=null;
let pdfDoc=null;
let selectedArea=null;
let processedBytes=null;

document.getElementById('pdfInput').addEventListener('change',async function(e){

  const file=e.target.files[0];
  if(!file) return;

  originalBytes=await file.arrayBuffer();
  pdfDoc=await PDFLib.PDFDocument.load(originalBytes);

  document.getElementById("original").innerHTML="";
  document.getElementById("processed").innerHTML="";

  renderPDF(originalBytes,"original",true);
});

/* ========= RENDER ========= */

async function renderPDF(bytes,containerId,enableDraw=false){

  const pdf=await pdfjsLib.getDocument({data:bytes}).promise;
  const container=document.getElementById(containerId);

  for(let i=1;i<=pdf.numPages;i++){

    const page=await pdf.getPage(i);
    const viewport=page.getViewport({scale:1});
    const canvas=document.createElement("canvas");
    const ctx=canvas.getContext("2d");

    canvas.width=viewport.width;
    canvas.height=viewport.height;

    await page.render({canvasContext:ctx,viewport}).promise;

    if(enableDraw){
      enableDrawing(canvas);
    }

    container.appendChild(canvas);
  }
}

/* ========= MANUAL SELECT ========= */

function enableManualSelect(){
  alert("Draw selection box on Original preview");
}

function enableDrawing(canvas){

  let startX,startY,isDrawing=false;
  const wrapper=document.createElement("div");
  wrapper.className="canvas-wrapper";
  canvas.parentNode?.insertBefore(wrapper,canvas);
  wrapper.appendChild(canvas);

  const box=document.createElement("div");
  box.className="selection-box";
  wrapper.appendChild(box);

  canvas.addEventListener("mousedown",(e)=>{
    isDrawing=true;
    startX=e.offsetX;
    startY=e.offsetY;
  });

  canvas.addEventListener("mousemove",(e)=>{
    if(!isDrawing) return;
    const width=e.offsetX-startX;
    const height=e.offsetY-startY;
    box.style.left=startX+"px";
    box.style.top=startY+"px";
    box.style.width=width+"px";
    box.style.height=height+"px";
  });

  canvas.addEventListener("mouseup",(e)=>{
    isDrawing=false;
    selectedArea={
      x:startX,
      y:canvas.height-(e.offsetY),
      width:e.offsetX-startX,
      height:e.offsetY-startY
    };
  });
}

/* ========= BLUR ========= */

async function applyBlur(){

  if(!selectedArea) return alert("Select area first");

  const pages=pdfDoc.getPages();

  pages.forEach(page=>{
    page.drawRectangle({
      x:selectedArea.x,
      y:selectedArea.y,
      width:selectedArea.width,
      height:selectedArea.height,
      color:PDFLib.rgb(1,1,1),
      opacity:0.6
    });
  });

  processedBytes=await pdfDoc.save();
  document.getElementById("processed").innerHTML="";
  renderPDF(processedBytes,"processed");
}

/* ========= DARK MODE ========= */

async function applyDarkMode(){

  const pages=pdfDoc.getPages();

  pages.forEach(page=>{
    const {width,height}=page.getSize();
    page.drawRectangle({
      x:0,
      y:0,
      width:width,
      height:height,
      color:PDFLib.rgb(1,1,1),
      opacity:0.05
    });
  });

  processedBytes=await pdfDoc.save();
  document.getElementById("processed").innerHTML="";
  renderPDF(processedBytes,"processed");
}

/* ========= TEXT REMOVE ========= */

async function removeTextWatermark(){

  alert("Basic text layer removal applied");

  const pages=pdfDoc.getPages();

  pages.forEach(page=>{
    page.drawRectangle({
      x:0,
      y:page.getHeight()/2,
      width:page.getWidth(),
      height:100,
      color:PDFLib.rgb(1,1,1)
    });
  });

  processedBytes=await pdfDoc.save();
  document.getElementById("processed").innerHTML="";
  renderPDF(processedBytes,"processed");
}

/* ========= DOWNLOAD ========= */

function downloadPDF(){

  if(!processedBytes) return alert("Apply removal first");

  const blob=new Blob([processedBytes],{type:"application/pdf"});
  const link=document.createElement("a");
  link.href=URL.createObjectURL(blob);
  link.download="cleaned.pdf";
  link.click();
}

</script>
</body>
</html>
